### Анализ синтаксического дерева

Для построения абстрактного синтаксического дерева была использована библиотека FParsec, которая позволила объединить лексический и синтаксический анализ в единый парсер. AST представляется типом Expression, который содержит различные конструкции языка, в том числе самого себя, т.е. это рекурсивный тип. 

В языке реализовано:
- Строки
- Числа
- Переменные
- Условные операторы
- Объявления
- Функции, в том числе и рекурсивные

Окружение хранится в словаре, позволяя реализовать замыкания и рекурсивные функции.


### Интерпретатор

Для выполнения программы был реализован eval-apply интерпретатор, который осуществляет обход AST с его дальнейшим упрощением в плоть до того, как не будет получен результат всей программы. Внутри двух функций `eval` и `apply` выполняется сопоставление с образцом и в зависимости от типа текущего выражения мы его преобразуем для дальнейшей работы. Например, для `Lambda` будет возвращено замыкание, а для условного выражение вычислится `condition` и в зависимости от его истинности будет возвращена либо ветка с `if`, либо ветка с `else`. Оператор Let добавляет выражение в окружение, выражение может быть и функция. Оператор RecursiveLet добавляет рекурсивную функцию в окружение. Для Application будет вычислена левая и правая части выражения и продолжено вычисление. Для примитивный типов, как `Int, Float, String, Boolean` возвращаются сами значения. А когда мы встречаем `Variable`, то пара `<Имя, Значеие>` добавляются в окружение для дальнейшего использования. В случае, если не произошло ни одного сопаставления с шаблоном, значит дерево является неверным. Будет выброшено исключение.


### Кроме того, реализованы следующие функции:

- Именованные переменные (let)
- Рекурсия
- Функции
- Замыкания

### Поддерживаемые типы

1) Int
2) Float
3) String
4) Boolean

Типизация в языке динамическая, не строгая. В языке присутствует приведение типов int -> float


### Синтаксис языка и примеры

- Объявление переменной / не рекурсивной фунции:
```
let variable_name = value
let x = int 5

let sum = lambda (a, b) {
    (a + b)
}
```

- Объявление рекурсивной функции и ее вызов
```
reclet factorial = lambda (n) {
    if (n <= 1) {
        1
    } else {
        (n * exec factorial ((n - 1)))
    }
}

exec factorial (5)
```
Результатом данной функции будет `Int 120`

- Динамическая типизация, а так же пример с конкатенацией строк:

```

let sum = lambda (a, b) {
    (a + b)
}

let lhs = str "HELLO "
let rhs = bool false
let rhs = str "WORLD!!!"

exec sum (lhs, rhs)

```
Результатом будет `String "HELLO WORLD!!!"`

- Ещё один пример, на этот раз вычисление числа Фибоначчи
```
reclet fib = lambda (n) {
    if (n <= int 1) {
        int 1
    } else {
        (exec fib ((n - int 1)) + exec fib ((n - int 2)))
    }
}

exec fib (int 9)
```
